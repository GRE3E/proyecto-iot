#include <Wire.h>
#include <LiquidCrystal_I2C.h>

// ---- Configuración LCD 16x2 ----
// Ahora PCF8574-based, dirección 0x27
LiquidCrystal_I2C lcd(0x27, 16, 2);

unsigned long ultimoTiempo = 0;
const unsigned long intervalo = 1000; // cada 1 segundo consulta esclavo 9
String ultimaRespuestaLCD = ""; // Para evitar parpadeo

void setup() {
  Wire.begin(); // Master
  Serial.begin(9600);

  // ---- Inicializar LCD ----
  lcd.init();        // Inicializar LCD
  lcd.backlight();   // Encender luz de fondo
  lcd.setCursor(0, 0);
  lcd.print("Master iniciado");
  lcd.setCursor(0, 1);
  lcd.print("Esperando cmd...");

  // *** MODIFICACIÓN: Mensaje de bienvenida actualizado para el nuevo formato de comando ***
  Serial.println("Master listo. Ingresa comandos: <ID> <DEVICE_TYPE_INDEX> <VALUE>");
  Serial.println("Ejemplo: 8 LIGHT_1 ON  |  9 MOTOR_2 SPEED_50");
}

void loop() {
  // ---- Comandos desde consola (o desde Python via Serial) ----
  if (Serial.available()) {
    String comandoCompleto = Serial.readStringUntil('\n');
    comandoCompleto.trim();

    if (comandoCompleto.length() > 0) {
      // *** MODIFICACIÓN: Parsear el comando completo en el nuevo formato "ID DEVICE_TYPE_INDEX VALUE" ***
      int firstSpace = comandoCompleto.indexOf(' ');
      int secondSpace = comandoCompleto.indexOf(' ', firstSpace + 1);

      if (firstSpace == -1 || secondSpace == -1) {
        Serial.println("ERROR: Comando invalido. Formato: <ID> <DEVICE_TYPE_INDEX> <VALUE>");
        // *** MODIFICACIÓN: Enviar un mensaje de error a Python si el formato es incorrecto ***
        Serial.println("ERROR:ARDUINO_MASTER:COMMAND:INVALID:" + comandoCompleto);
        return;
      }

      int arduinoId = comandoCompleto.substring(0, firstSpace).toInt();
      String deviceTypeIndex = comandoCompleto.substring(firstSpace + 1, secondSpace); // Ej: "LIGHT_1", "MOTOR_2"
      String value = comandoCompleto.substring(secondSpace + 1); // Ej: "ON", "SPEED_50"

      // Extraer DEVICE_TYPE y DEVICE_INDEX de deviceTypeIndex
      // Extraer DEVICE_TYPE y DEVICE_INDEX de deviceTypeIndex
      int lastUnderscoreIndex = deviceTypeIndex.lastIndexOf('_');
      String deviceType = deviceTypeIndex;
      String deviceIndex = "1"; // Valor por defecto si no se proporciona un índice

      if (lastUnderscoreIndex != -1) {
        deviceType = deviceTypeIndex.substring(0, lastUnderscoreIndex);
        deviceIndex = deviceTypeIndex.substring(lastUnderscoreIndex + 1);
      }

      // Mensaje a enviar al esclavo via I2C.
      // Enviamos 'deviceTypeIndex value' para que el esclavo lo interprete.
      String mensajeParaEsclavo = deviceTypeIndex + " " + value;

      // Enviar al esclavo via I2C
      Wire.beginTransmission(arduinoId);
      Wire.write(mensajeParaEsclavo.c_str(), mensajeParaEsclavo.length());
      byte error = Wire.endTransmission(); // Capturar el resultado de la transmisión

      delay(50); // Pequeña espera para que el esclavo procese

      // Leer respuesta inmediata del esclavo
      Wire.requestFrom(arduinoId, 32);
      String respuestaEsclavo = "";
      while (Wire.available()) {
        char c = Wire.read();
        if (c >= 32 && c <= 126) respuestaEsclavo += c; // Solo caracteres imprimibles
      }
      respuestaEsclavo.trim();

      // *** MODIFICACIÓN: Enviar confirmación a Python en el nuevo formato ***
      // Formato: CONFIRM:ARDUINO_ID:DEVICE_TYPE:DEVICE_INDEX:VALUE
      String pythonConfirmMsg;
      if (error == 0) { // Si la transmisión I2C fue exitosa
          // Check if the slave response contains data that should be used as the VALUE
          int colonIndexInResponse = respuestaEsclavo.indexOf(':');
          if (colonIndexInResponse != -1) {
            // If the response is in "DEVICE_TYPE_INDEX:VALUE" format, extract the value
            String responseValue = respuestaEsclavo.substring(colonIndexInResponse + 1);
            pythonConfirmMsg = "CONFIRM:ARDUINO_" + String(arduinoId) + ":" + deviceType + ":" + deviceIndex + ":" + responseValue;
          } else {
            // Otherwise, use the original command's value or the full slave response if it's not empty
            if (respuestaEsclavo.length() > 0) {
                pythonConfirmMsg = "CONFIRM:ARDUINO_" + String(arduinoId) + ":" + deviceType + ":" + deviceIndex + ":" + respuestaEsclavo;
            } else {
                pythonConfirmMsg = "CONFIRM:ARDUINO_" + String(arduinoId) + ":" + deviceType + ":" + deviceIndex + ":" + value;
            }
          }
      } else {
          // Si hubo un error en la transmisión I2C
          pythonConfirmMsg = "CONFIRM:ARDUINO_" + String(arduinoId) + ":" + deviceType + ":" + deviceIndex + ":FAILED_I2C_ERROR_" + String(error);
      }
      Serial.println(pythonConfirmMsg);


      // ---- Mostrar en LCD solo si hay cambio ----
      if (arduinoId != 9) { // Solo actualizar LCD para respuestas de comandos si no es el Esclavo 9
        String lcdTexto = "ID " + String(arduinoId) + " -> ";
        lcdTexto += (respuestaEsclavo.length() > 0) ? respuestaEsclavo : mensajeParaEsclavo;

        if (lcdTexto != ultimaRespuestaLCD) {
          lcd.clear();
          lcd.setCursor(0,0);
          lcd.print(lcdTexto.substring(0,16));
          lcd.setCursor(0,1);
          if (lcdTexto.length() > 16) lcd.print(lcdTexto.substring(16,32));
          ultimaRespuestaLCD = lcdTexto;
        }
      }
    }
  }

  // ---- Consulta periódica al esclavo 9 ----
  unsigned long ahora = millis();
  if (ahora - ultimoTiempo >= intervalo) {
    ultimoTiempo = ahora;

    Wire.requestFrom(9, 32); // Solicitar datos del esclavo 9
    String respuestaEsclavo = "";
    while (Wire.available()) {
      char c = Wire.read();
      if (c >= 32 && c <= 126) respuestaEsclavo += c;
    }
    respuestaEsclavo.trim();

    if (respuestaEsclavo.length() > 0) {
      // *** MODIFICACIÓN: Esperamos que el esclavo 9 responda en el formato "DEVICE_TYPE_INDEX:VALUE" ***
      // Ej: "TEMP_SENSOR_1:25.5", "HUMIDITY_1:60"
      int colonIndex = respuestaEsclavo.indexOf(':');
      if (colonIndex != -1) {
        String deviceTypeIndex = respuestaEsclavo.substring(0, colonIndex); // Ej: "TEMP_SENSOR_1"
        String value = respuestaEsclavo.substring(colonIndex + 1); // Ej: "25.5"

        // Extraer DEVICE_TYPE y DEVICE_INDEX de deviceTypeIndex
        int lastUnderscoreIndex = deviceTypeIndex.lastIndexOf('_');
        String deviceType = deviceTypeIndex;
        String deviceIndex = "1"; // Valor por defecto

        if (lastUnderscoreIndex != -1) {
          deviceType = deviceTypeIndex.substring(0, lastUnderscoreIndex);
          deviceIndex = deviceTypeIndex.substring(lastUnderscoreIndex + 1);
        }

        // *** MODIFICACIÓN: Enviar datos a Python en el nuevo formato ***
        // Formato: DATA:ARDUINO_ID:DEVICE_TYPE:DEVICE_INDEX:VALUE
        // String pythonDataMsg = "DATA:ARDUINO_9:" + deviceType + ":" + deviceIndex + ":" + value;
        // Serial.println(pythonDataMsg);

        if (deviceType == "TEMP_SENSOR") {
          if (respuestaEsclavo != ultimaRespuestaLCD) {
            lcd.clear();
            lcd.setCursor(0,0);
            lcd.print("Temperatura:");
            lcd.setCursor(0,1);
            lcd.print(value);
            ultimaRespuestaLCD = respuestaEsclavo;
          }
        } else { // Para otros tipos de datos del Esclavo 9
          if (respuestaEsclavo != ultimaRespuestaLCD) {
            lcd.clear();
            lcd.setCursor(0,0);
            lcd.print("Estado");
            lcd.setCursor(0,1);
            lcd.print(respuestaEsclavo.substring(0,16));
            ultimaRespuestaLCD = respuestaEsclavo;
          }
        }
      } else {
        // Si el esclavo 9 envía un mensaje simple sin el formato esperado,
        // lo enviamos a Python como un tipo desconocido para depuración.
        Serial.println("DATA:ARDUINO_9:UNKNOWN:1:" + respuestaEsclavo);
      }
    }
  }
}