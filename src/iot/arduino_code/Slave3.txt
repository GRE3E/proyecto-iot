#include <ESP8266WiFi.h>
#include <PubSubClient.h>
#include <Servo.h>

// === Configuración WiFi ===
const char* ssid = "YOUR_WIFI_SSID"; // Reemplaza con tu SSID
const char* password = "YOUR_WIFI_PASSWORD"; // Reemplaza con tu contraseña

// === Configuración MQTT ===
const char* mqtt_server = "YOUR_MQTT_BROKER_IP"; // Reemplaza con la IP de tu broker MQTT
const int mqtt_port = 1883; // Puerto MQTT estándar
const char* mqtt_client_id = "EsclavoPuertas"; // ID único para este cliente MQTT

WiFiClient espClient;
PubSubClient client(espClient);

// ---- Pines de los servos ----
const int puertaP = 2;       // Puerta principal
const int puertaGaraje = 3;
const int puertaGarInt = 4;
const int puertaHabInv = 5;
const int puertaBaInv = 6;
const int puertaLav = 7;
const int puertaHabP = 8;
const int puertaBaHP = 9;   // Ultima puerta

// ---- Objetos Servo ----
Servo sPuertaP, sPuertaGaraje, sPuertaGarInt, sPuertaHabInv;
Servo sPuertaBaInv, sPuertaLav, sPuertaHabP, sPuertaBaHP;

Servo* servos[8]; // Array de punteros a objetos Servo

// ---- Nombres de las puertas y tópicos MQTT ----
struct Puerta {
  String nombre;
  Servo* servo;
  bool estado;
  const char* topic_comando;
  const char* topic_estado;
};

Puerta puertas[] = {
  {"Puerta Principal", &sPuertaP, false, "iot/puertas/principal/comando", "iot/puertas/principal/estado"},
  {"Puerta Garaje", &sPuertaGaraje, false, "iot/puertas/garaje/comando", "iot/puertas/garaje/estado"},
  {"Puerta Garaje Interior", &sPuertaGarInt, false, "iot/puertas/garaje_interior/comando", "iot/puertas/garaje_interior/estado"},
  {"Puerta Habitación Invitados", &sPuertaHabInv, false, "iot/puertas/habitacion_invitados/comando", "iot/puertas/habitacion_invitados/estado"},
  {"Puerta Baño Invitados", &sPuertaBaInv, false, "iot/puertas/bano_invitados/comando", "iot/puertas/bano_invitados/estado"},
  {"Puerta Lavandería", &sPuertaLav, false, "iot/puertas/lavanderia/comando", "iot/puertas/lavanderia/estado"},
  {"Puerta Habitación Principal", &sPuertaHabP, false, "iot/puertas/habitacion_principal/comando", "iot/puertas/habitacion_principal/estado"},
  {"Puerta Baño Habitación Principal", &sPuertaBaHP, false, "iot/puertas/bano_habitacion_principal/comando", "iot/puertas/bano_habitacion_principal/estado"}
};

// === Declaraciones de funciones ===
void setup_wifi();
void callback(char* topic, byte* payload, unsigned int length);
void reconnect();
void moverPuerta(Puerta &puerta, const String &accion);
void cerrarTodo();

void setup_wifi() {
  delay(10);
  Serial.println();
  Serial.print("Conectando a ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("");
  Serial.println("WiFi conectado");
  Serial.print("Dirección IP: ");
  Serial.println(WiFi.localIP());
}

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Mensaje recibido en el tópico: ");
  Serial.print(topic);
  Serial.print(" -> ");
  String mensaje = "";
  for (int i = 0; i < length; i++) {
    mensaje += (char)payload[i];
  }
  Serial.println(mensaje);

  // Procesar comandos para las puertas
  for (int i = 0; i < sizeof(puertas) / sizeof(puertas[0]); i++) {
    if (strcmp(topic, puertas[i].topic_comando) == 0) {
      moverPuerta(puertas[i], mensaje);
      break;
    }
  }
}

void reconnect() {
  while (!client.connected()) {
    Serial.print("Intentando conexión MQTT...");
    if (client.connect(mqtt_client_id)) {
      Serial.println("conectado");
      // Suscribirse a los tópicos de comando de todas las puertas
      for (int i = 0; i < sizeof(puertas) / sizeof(puertas[0]); i++) {
        client.subscribe(puertas[i].topic_comando);
        Serial.print("Suscrito a: ");
        Serial.println(puertas[i].topic_comando);
      }
      // Publicar estado inicial de todas las puertas
      for (int i = 0; i < sizeof(puertas) / sizeof(puertas[0]); i++) {
        client.publish(puertas[i].topic_estado, puertas[i].estado ? "ABIERTA" : "CERRADA");
      }
    } else {
      Serial.print("falló, rc=");
      Serial.print(client.state());
      Serial.println(" intentando de nuevo en 5 segundos");
      delay(5000);
    }
  }
}

void setup() {
  Serial.begin(115200); // Usar una velocidad de baudios más alta para ESP8266
  setup_wifi();
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(callback);

  // ---- Vincular servos y asignar al array ----
  sPuertaP.attach(puertaP);
  servos[0] = &sPuertaP;
  sPuertaGaraje.attach(puertaGaraje);
  servos[1] = &sPuertaGaraje;
  sPuertaGarInt.attach(puertaGarInt);
  servos[2] = &sPuertaGarInt;
  sPuertaHabInv.attach(puertaHabInv);
  servos[3] = &sPuertaHabInv;
  sPuertaBaInv.attach(puertaBaInv);
  servos[4] = &sPuertaBaInv;
  sPuertaLav.attach(puertaLav);
  servos[5] = &sPuertaLav;
  sPuertaHabP.attach(puertaHabP);
  servos[6] = &sPuertaHabP;
  sPuertaBaHP.attach(puertaBaHP);
  servos[7] = &sPuertaBaHP;

  // Asignar servos a la estructura de puertas
  for (int i = 0; i < 8; i++) {
    puertas[i].servo = servos[i];
  }

  cerrarTodo(); // Asegura que todas las puertas esten cerradas al inicio
  Serial.println("Esclavo de Puertas listo (MQTT)");
}

void loop() {
  if (!client.connected()) {
    reconnect();
  }
  client.loop();
}

// ---- Mover un servo y actualizar estado ----
void moverPuerta(Puerta &puerta, const String &accion) {
  if (accion == "ABRIR") {
    if (!puerta.estado) {
      puerta.servo->write(90);  // Angulo de apertura (ajustable)
      puerta.estado = true;
      client.publish(puerta.topic_estado, "ABIERTA");
      Serial.print(puerta.nombre + " ABIERTA");
    } else {
      client.publish(puerta.topic_estado, "YA_ABIERTA");
      Serial.print(puerta.nombre + " YA_ABIERTA");
    }
  } else if (accion == "CERRAR") {
    if (puerta.estado) {
      puerta.servo->write(0);   // Angulo de cierre
      puerta.estado = false;
      client.publish(puerta.topic_estado, "CERRADA");
      Serial.print(puerta.nombre + " CERRADA");
    } else {
      client.publish(puerta.topic_estado, "YA_CERRADA");
      Serial.print(puerta.nombre + " YA_CERRADA");
    }
  } else if (accion == "ESTADO") {
    client.publish(puerta.topic_estado, puerta.estado ? "ABIERTA" : "CERRADA");
    Serial.print("Estado de " + puerta.nombre + " solicitado.");
  }
  else {
    client.publish(puerta.topic_estado, "COMANDO_INVALIDO");
    Serial.print("Comando invalido para " + puerta.nombre);
  }
  Serial.println();
}

// ---- Cerrar todas las puertas ----
void cerrarTodo() {
  for (int i = 0; i < sizeof(puertas) / sizeof(puertas[0]); i++) {
    puertas[i].servo->write(0);
    puertas[i].estado = false;
    // No publicar aquí, se publicará en reconnect()
  }
  Serial.println("Todas las puertas cerradas al inicio.");
}
