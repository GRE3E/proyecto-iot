// ========================================
// ESP8266 - WiFi_Gateway.ino
// ========================================
#include <ESP8266WiFi.h>
#include <PubSubClient.h>
#include <Wire.h>

const char* ssid = "IoT_Murphy_Home";
const char* password = "Home_IoT_Murphy";

const char* mqtt_server = "192.168.137.1";
const int mqtt_port = 1883;
const char* mqtt_client_id = "ESP8266_HomeGateway";

#define SLAVE_LUCES_ADDRESS 8
#define SLAVE_SENSORES_ADDRESS 9
#define SLAVE_PUERTAS_ADDRESS 10

struct DeviceMap {
  String name;
  int index;
};

DeviceMap luces[] = {
  {"GARAJE", 0},
  {"PASILLO", 1},
  {"HABITACION_INVITADOS", 2},
  {"BANO_INVITADOS", 3},
  {"LAVANDERIA", 4},
  {"BANO_PRINCIPAL", 5},
  {"HABITACION_PRINCIPAL", 6},
  {"COCINA", 7},
  {"SALA", 8}
};

DeviceMap puertas[] = {
  {"PRINCIPAL", 0},
  {"GARAJE", 1},
  {"PASILLO", 2},
  {"HABITACION_INVITADOS", 3},
  {"BANO_INVITADOS", 4},
  {"LAVANDERIA", 5},
  {"BANO_PRINCIPAL", 6},
  {"HABITACION_PRINCIPAL", 7}
};

WiFiClient espClient;
PubSubClient client(espClient);

String serialBuffer = "";
unsigned long ultimaLectura = 0;
const unsigned long intervaloLectura = 5000;
bool dentroCallback = false;

int getLuzIndex(String nombre) {
  nombre.toUpperCase();
  for (int i = 0; i < 9; i++) {
    if (nombre.indexOf(luces[i].name) != -1) {
      return luces[i].index;
    }
  }
  return -1;
}

int getPuertaIndex(String nombre) {
  nombre.toUpperCase();
  for (int i = 0; i < 8; i++) {
    if (nombre.indexOf(puertas[i].name) != -1) {
      return puertas[i].index;
    }
  }
  return -1;
}

String getLuzName(int index) {
  if (index >= 0 && index < 9) return luces[index].name;
  return "DESCONOCIDA";
}

String getPuertaName(int index) {
  if (index >= 0 && index < 8) return puertas[index].name;
  return "DESCONOCIDA";
}

void consolePrint(const char* message) {
  Serial.println(message);
  if (!dentroCallback && client.connected()) {
    client.publish("iot/system/console", message);
  }
}

void consolePrint(const __FlashStringHelper* message) {
  Serial.println(message);
  if (!dentroCallback && client.connected()) {
    client.publish("iot/system/console", (const char*)message);
  }
}

void publicarConfirmacion(const char* tipo, const char* dispositivo, const char* accion, const char* estado, bool exito) {
  char mensaje[200]; // Buffer para el mensaje de confirmación
  snprintf(mensaje, sizeof(mensaje), "%s|%s|%s|%s|%s|%lu",
           tipo, dispositivo, accion, estado, (exito ? "OK" : "ERROR"), millis());
  client.publish("iot/system/confirmations", mensaje);
  
  char consoleBuffer[250]; // Buffer para los mensajes de consola

  consolePrint(F("\n=== CONFIRMACION ==="));
  snprintf(consoleBuffer, sizeof(consoleBuffer), "Tipo: %s", tipo);
  consolePrint(consoleBuffer);
  snprintf(consoleBuffer, sizeof(consoleBuffer), "Dispositivo: %s", dispositivo);
  consolePrint(consoleBuffer);
  snprintf(consoleBuffer, sizeof(consoleBuffer), "Accion: %s", accion);
  consolePrint(consoleBuffer);
  snprintf(consoleBuffer, sizeof(consoleBuffer), "Estado: %s", estado);
  consolePrint(consoleBuffer);
  snprintf(consoleBuffer, sizeof(consoleBuffer), "Resultado: %s", (exito ? "OK" : "ERROR"));
  consolePrint(consoleBuffer);
  consolePrint(F("====================\n"));
}

void setup_wifi() {
  delay(1000);
  consolePrint(F("\nIniciando conexion WiFi..."));
  Serial.print(F("Red: "));
  consolePrint(ssid);
  
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  
  int retries = 0;
  while (WiFi.status() != WL_CONNECTED && retries < 60) {
    delay(500);
    Serial.print(F("."));
    retries++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    consolePrint(F("\nWiFi conectado"));
    Serial.print(F("IP: "));
    
    char ipBuffer[20];
    IPAddress ip = WiFi.localIP();
    sprintf(ipBuffer, "%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);
    consolePrint(ipBuffer);
  } else {
    consolePrint(F("\nERROR: No se pudo conectar a WiFi"));
  }
}

void callback(char* topic, byte* payload, unsigned int length) {
  dentroCallback = true;
  
  Serial.print(F("\nMQTT recibido en ["));
  Serial.print(topic);
  Serial.println(F("]"));
  
  char message[200];
  unsigned int i;
  for (i = 0; i < length && i < sizeof(message) - 1; i++) {
    message[i] = (char)payload[i];
  }
  message[i] = '\0';
  
  // Convert message to uppercase
  for (i = 0; i < strlen(message); i++) {
    message[i] = toupper(message[i]);
  }
  
  Serial.print(F("Comando: "));
  Serial.println(message);
  
  char topicUpper[100];
  strcpy(topicUpper, topic);
  for (i = 0; i < strlen(topicUpper); i++) {
    topicUpper[i] = toupper(topicUpper[i]);
  }
  
  char comando[300];
  snprintf(comando, sizeof(comando), "%s|%s", topicUpper, message);
  procesarComando(comando);
  
  dentroCallback = false;
}

void reconnect() {
  while (!client.connected() && WiFi.status() == WL_CONNECTED) {
    Serial.print(F("Conectando a MQTT broker..."));
    
    if (client.connect(mqtt_client_id)) {
      consolePrint(F(" Conectado!"));
      
      client.subscribe(F("iot/lights/+/command"));
      client.subscribe(F("iot/lights/+/status/get"));
      client.subscribe(F("iot/doors/+/command"));
      client.subscribe(F("iot/doors/+/status/get"));
      client.subscribe(F("iot/actuators/VENTILADOR/command"));
      client.subscribe(F("iot/actuators/VENTILADOR/status/get"));
      client.subscribe(F("iot/system/command"));
      client.subscribe(F("iot/system/console/get"));
      
      consolePrint(F("Suscrito a topicos"));
      client.publish(F("iot/system/gateway/status"), F("ONLINE"));
      
    } else {
      char consoleBuffer[100];
      snprintf(consoleBuffer, sizeof(consoleBuffer), " Fallo (rc=%d) - reintentando en 5s", client.state());
      Serial.print(consoleBuffer);
      consolePrint(F("")); // Imprimir una línea nueva después del mensaje de error
      delay(5000);
    }
  }
}

void leerEstadoLuz(int index) {
  if (index < 0 || index >= 9) return;
  
  byte estado = '0';
  
  char nombreLuzBuffer[20];
  getLuzName(index).toCharArray(nombreLuzBuffer, sizeof(nombreLuzBuffer));
  
  char consoleBuffer[100];
  snprintf(consoleBuffer, sizeof(consoleBuffer), "Luz %s: %s (Lectura I2C deshabilitada en Wifi.txt)", nombreLuzBuffer, (estado == '1') ? "ON" : "OFF");
  consolePrint(consoleBuffer);
}

void leerEstadoPuerta(int index) {
  if (index < 0 || index >= 8) return;
  
  byte estado = '0';
  
  char nombrePuertaBuffer[20];
  getPuertaName(index).toCharArray(nombrePuertaBuffer, sizeof(nombrePuertaBuffer));
  
  char consoleBuffer[100];
  snprintf(consoleBuffer, sizeof(consoleBuffer), "Puerta %s: %s (Lectura I2C deshabilitada en Wifi.txt)", nombrePuertaBuffer, (estado == '1') ? "OPEN" : "CLOSED");
  consolePrint(consoleBuffer);
}

void leerEstadoVentilador() {
  consolePrint(F("Ventilador: Estado no disponible (Lectura I2C deshabilitada en Wifi.txt)"));
}

void publicarBufferSerial() {
  if (serialBuffer.length() > 0) {
    client.publish("iot/system/console", serialBuffer.c_str());
    serialBuffer = "";
  }
}

void procesarComando(String cmd) {
  if (cmd.length() == 0) return;
  
  cmd.trim();
  cmd.toUpperCase();
  
  if (cmd.indexOf("IOT/SYSTEM/CONSOLE/GET") != -1) {
    publicarBufferSerial();
    return;
  }
  
  char consoleBuffer[100];
  snprintf(consoleBuffer, sizeof(consoleBuffer), "Procesando: %s", cmd.c_str());
  consolePrint(consoleBuffer);
  
  // Enviar el comando completo al Master
  enviarComandoI2C(cmd.c_str());
  
  // Extraer información para la confirmación
  char tipo[20] = "";
  char dispositivo[50] = "";
  char accion[50] = "";
  char estado[50] = "";
  
  if (cmd.indexOf("IOT/LIGHTS/") != -1) {
    strcpy(tipo, "LIGHT");
    int start = cmd.indexOf("LIGHT_") + 6;
    int end = cmd.indexOf("/COMMAND");
    if (start > 6 && end != -1) {
      cmd.substring(start, end).toCharArray(dispositivo, sizeof(dispositivo));
    }
    int pipePos = cmd.indexOf("|");
    if (pipePos != -1) {
      cmd.substring(pipePos + 1).toCharArray(accion, sizeof(accion));
      strcpy(estado, accion);
    }
  }
  else if (cmd.indexOf("IOT/DOORS/") != -1) {
    strcpy(tipo, "DOOR");
    int start = cmd.indexOf("DOOR_") + 5;
    int end = cmd.indexOf("/COMMAND");
    if (start > 5 && end != -1) {
      cmd.substring(start, end).toCharArray(dispositivo, sizeof(dispositivo));
    }
    int pipePos = cmd.indexOf("|");
    if (pipePos != -1) {
      cmd.substring(pipePos + 1).toCharArray(accion, sizeof(accion));
      strcpy(estado, accion);
    }
  }
  else if (cmd.indexOf("IOT/ACTUATORS/VENTILADOR") != -1) {
    strcpy(tipo, "ACTUATOR");
    strcpy(dispositivo, "VENTILADOR");
    int pipePos = cmd.indexOf("|");
    if (pipePos != -1) {
      cmd.substring(pipePos + 1).toCharArray(accion, sizeof(accion));
      strcpy(estado, accion);
    }
  }
  else if (cmd.indexOf("IOT/SYSTEM/COMMAND") != -1) {
    strcpy(tipo, "SYSTEM");
    strcpy(dispositivo, "COMMAND");
    int pipePos = cmd.indexOf("|");
    if (pipePos != -1) {
      cmd.substring(pipePos + 1).toCharArray(accion, sizeof(accion));
      strcpy(estado, accion);
    }
  }
  
  if (strlen(tipo) > 0) {
    publicarConfirmacion(tipo, dispositivo, accion, estado, true);
  }
}

void enviarComandoI2C(const char* comando) {
  Wire.beginTransmission(1); // Dirección del Master
  Wire.write((const uint8_t*)comando, strlen(comando));
  byte error = Wire.endTransmission();
  
  if (error != 0) {
    char consoleBuffer[100];
    snprintf(consoleBuffer, sizeof(consoleBuffer), "ERROR I2C Master (codigo: %d)", error);
    consolePrint(consoleBuffer);
    client.publish("iot/system/gateway/error", "I2C Error: No se pudo enviar comando al Master");
  }
  delay(50);
}

void leerYPublicarEstados() {
  consolePrint(F("\n--- Leyendo Estados ---"));
  
  consolePrint(F("Estados de Luces: No disponibles (Lectura I2C deshabilitada en Wifi.txt)"));
  
  consolePrint(F("Estados de Sensores: No disponibles (Lectura I2C deshabilitada en Wifi.txt)"));
  
  consolePrint(F("Estados de Puertas: No disponibles (Lectura I2C deshabilitada en Wifi.txt)"));
  
  consolePrint(F("--- Fin Estados ---\n"));
}

void leerSerial() {
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\n' || c == '\r') {
      if (serialBuffer.length() > 0) {
        procesarComando(serialBuffer);
        serialBuffer = "";
      }
    } else {
      serialBuffer += c;
    }
  }
}

void receiveEvent(int howMany) {
  char receivedMessage[200];
  int i = 0;
  while (Wire.available() && i < sizeof(receivedMessage) - 1) {
    char c = Wire.read();
    receivedMessage[i++] = c;
  }
  receivedMessage[i] = '\0'; // Null-terminate the string
  
  if (strlen(receivedMessage) > 0) {
    char consoleBuffer[250];
    if (strstr(receivedMessage, "CONSOLE|") == receivedMessage) {
      // Extraer el mensaje de consola
      char* token;
      char* rest = receivedMessage;
      
      token = strtok_r(rest, "|", &rest); // CONSOLE
      char* source = strtok_r(rest, "|", &rest);
      char* message = rest;

      if (source != NULL && message != NULL) {
        snprintf(consoleBuffer, sizeof(consoleBuffer), "[%s] %s", source, message);
        client.publish("iot/system/console", consoleBuffer);
      }
    } else if (strstr(receivedMessage, "STATE|") == receivedMessage) {
      // Extraer el mensaje de estado
      char* token;
      char* rest = receivedMessage;

      token = strtok_r(rest, "|", &rest); // STATE
      char* type = strtok_r(rest, "|", &rest);
      char* device = strtok_r(rest, "|", &rest);
      char* state = rest;
      
      char topic[100] = "";
      if (strcmp(type, "LIGHT") == 0) {
        snprintf(topic, sizeof(topic), "iot/lights/LIGHT_%s/status", device);
      } else if (strcmp(type, "DOOR") == 0) {
        snprintf(topic, sizeof(topic), "iot/doors/DOOR_%s/status", device);
      } else if (strcmp(type, "SENSOR") == 0 && strcmp(device, "TEMPERATURA") == 0) {
        strcpy(topic, "iot/sensors/TEMPERATURE/status");
      } else if (strcmp(type, "SENSOR") == 0 && strcmp(device, "DISTANCIA") == 0) {
        strcpy(topic, "iot/sensors/DISTANCE/status");
      } else if (strcmp(type, "ACTUATOR") == 0 && strcmp(device, "VENTILADOR") == 0) {
        strcpy(topic, "iot/actuators/VENTILADOR/status");
      }
      
      if (strlen(topic) > 0) {
        client.publish(topic, state);
      }
    }
  }
}


void setup() {
  Serial.begin(115200);
  delay(100);
  
  consolePrint(F("\n========================================"));
  consolePrint(F("   ESP8266 WiFi Gateway"));
  consolePrint(F("========================================"));
  
  Wire.begin(7); // ESP8266 como esclavo I2C con direccion 7
  Wire.onReceive(receiveEvent);
  Wire.setClock(100000);
  consolePrint(F("I2C inicializado como esclavo"));
  
  setup_wifi();
  
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(callback);
  
  consolePrint(F("\nSistema listo"));
  consolePrint(F("\nDispositivos disponibles:"));
  consolePrint(F("\nLuces:"));
  char consoleBuffer[100];
  for (int i = 0; i < 9; i++) {
    snprintf(consoleBuffer, sizeof(consoleBuffer), "  - LIGHT_%s", luces[i].name.c_str());
    consolePrint(consoleBuffer);
  }
  consolePrint(F("\nPuertas:"));
  for (int i = 0; i < 8; i++) {
    snprintf(consoleBuffer, sizeof(consoleBuffer), "  - DOOR_%s", puertas[i].name.c_str());
    consolePrint(consoleBuffer);
  }
  consolePrint(F("\nActuadores:"));
  consolePrint(F("  - VENTILADOR\n"));
}

void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    setup_wifi();
  }
  
  if (!client.connected()) {
    reconnect();
  }
  client.loop();
  
  leerSerial();
  
  if (millis() - ultimaLectura >= intervaloLectura) {
    ultimaLectura = millis();
    leerYPublicarEstados();
  }
}
