// ========================================
// ESP8266 - WiFi_Gateway.ino
// ========================================
#include <ESP8266WiFi.h>
#include <PubSubClient.h>
#include <Wire.h>

const char* ssid = "IoT_Murphy_Home";
const char* password = "Home_IoT_Murphy";

const char* mqtt_server = "192.168.137.1";
const int mqtt_port = 1883;
const char* mqtt_client_id = "ESP8266_HomeGateway";

#define SLAVE_LUCES_ADDRESS 8
#define SLAVE_SENSORES_ADDRESS 9
#define SLAVE_PUERTAS_ADDRESS 10

struct DeviceMap {
  String name;
  int index;
};

DeviceMap luces[] = {
  {"GARAJE", 0},
  {"PASILLO", 1},
  {"HABITACION_INVITADOS", 2},
  {"BANO_INVITADOS", 3},
  {"LAVANDERIA", 4},
  {"BANO_PRINCIPAL", 5},
  {"HABITACION_PRINCIPAL", 6},
  {"COCINA", 7},
  {"SALA", 8}
};

DeviceMap puertas[] = {
  {"PRINCIPAL", 0},
  {"GARAJE", 1},
  {"PASILLO", 2},
  {"HABITACION_INVITADOS", 3},
  {"BANO_INVITADOS", 4},
  {"LAVANDERIA", 5},
  {"BANO_PRINCIPAL", 6},
  {"HABITACION_PRINCIPAL", 7}
};

WiFiClient espClient;
PubSubClient client(espClient);

String serialBuffer = "";
unsigned long ultimaLectura = 0;
const unsigned long intervaloLectura = 5000;
bool dentroCallback = false;

int getLuzIndex(String nombre) {
  nombre.toUpperCase();
  for (int i = 0; i < 9; i++) {
    if (nombre.indexOf(luces[i].name) != -1) {
      return luces[i].index;
    }
  }
  return -1;
}

int getPuertaIndex(String nombre) {
  nombre.toUpperCase();
  for (int i = 0; i < 8; i++) {
    if (nombre.indexOf(puertas[i].name) != -1) {
      return puertas[i].index;
    }
  }
  return -1;
}

String getLuzName(int index) {
  if (index >= 0 && index < 9) return luces[index].name;
  return "DESCONOCIDA";
}

String getPuertaName(int index) {
  if (index >= 0 && index < 8) return puertas[index].name;
  return "DESCONOCIDA";
}

void consolePrint(String message) {
  Serial.println(message);
  if (!dentroCallback && client.connected()) {
    client.publish("iot/system/console", message.c_str());
  }
}

void publicarConfirmacion(String tipo, String dispositivo, String accion, String estado, bool exito) {
  String mensaje = tipo + "|" + dispositivo + "|" + accion + "|" + estado + "|" + (exito ? "OK" : "ERROR") + "|" + String(millis());
  client.publish("iot/system/confirmations", mensaje.c_str());
  
  consolePrint("\n=== CONFIRMACION ===");
  consolePrint("Tipo: " + tipo);
  consolePrint("Dispositivo: " + dispositivo);
  consolePrint("Accion: " + accion);
  consolePrint("Estado: " + estado);
  consolePrint("Resultado: " + String(exito ? "OK" : "ERROR"));
  consolePrint("====================\n");
}

void setup_wifi() {
  delay(1000);
  consolePrint("\nIniciando conexion WiFi...");
  Serial.print("Red: ");
  consolePrint(ssid);
  
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  
  int retries = 0;
  while (WiFi.status() != WL_CONNECTED && retries < 60) {
    delay(500);
    Serial.print(".");
    retries++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    consolePrint("\nWiFi conectado");
    Serial.print("IP: ");
    consolePrint(WiFi.localIP().toString());
  } else {
    consolePrint("\nERROR: No se pudo conectar a WiFi");
  }
}

void callback(char* topic, byte* payload, unsigned int length) {
  dentroCallback = true;
  
  Serial.print("\nMQTT recibido en [");
  Serial.print(topic);
  Serial.println("]");
  
  String message = "";
  for (unsigned int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  message.trim();
  
  Serial.print("Comando: ");
  Serial.println(message);
  
  String topicStr = String(topic);
  topicStr.toUpperCase();
  message.toUpperCase();
  
  String comando = topicStr + "|" + message;
  procesarComando(comando);
  
  dentroCallback = false;
}

void reconnect() {
  while (!client.connected() && WiFi.status() == WL_CONNECTED) {
    Serial.print("Conectando a MQTT broker...");
    
    if (client.connect(mqtt_client_id)) {
      consolePrint(" Conectado!");
      
      client.subscribe("iot/lights/+/command");
      client.subscribe("iot/lights/+/status/get");
      client.subscribe("iot/doors/+/command");
      client.subscribe("iot/doors/+/status/get");
      client.subscribe("iot/actuators/VENTILADOR/command");
      client.subscribe("iot/actuators/VENTILADOR/status/get");
      client.subscribe("iot/system/command");
      client.subscribe("iot/system/console/get");
      
      consolePrint("Suscrito a topicos");
      client.publish("iot/system/gateway/status", "ONLINE");
      
    } else {
      Serial.print(" Fallo (rc=");
      Serial.print(client.state());
      consolePrint(") - reintentando en 5s");
      delay(5000);
    }
  }
}

void leerEstadoLuz(int index) {
  if (index < 0 || index >= 9) return;
  
  byte estado = '0';
  
  String nombreLuz = getLuzName(index);
  String topic = "iot/lights/LIGHT_" + nombreLuz + "/status";
  String valor = (estado == '1') ? "ON" : "OFF";
  
  consolePrint("Luz " + nombreLuz + ": " + valor + " (Lectura I2C deshabilitada en Wifi.txt)");
}

void leerEstadoPuerta(int index) {
  if (index < 0 || index >= 8) return;
  
  byte estado = '0';
  
  String nombrePuerta = getPuertaName(index);
  String topic = "iot/doors/DOOR_" + nombrePuerta + "/status";
  String valor = (estado == '1') ? "OPEN" : "CLOSED";
  
  consolePrint("Puerta " + nombrePuerta + ": " + valor + " (Lectura I2C deshabilitada en Wifi.txt)");
}

void leerEstadoVentilador() {
  String datos = "";
  
  consolePrint("Ventilador: Estado no disponible (Lectura I2C deshabilitada en Wifi.txt)");
}

void publicarBufferSerial() {
  if (serialBuffer.length() > 0) {
    client.publish("iot/system/console", serialBuffer.c_str());
    serialBuffer = "";
  }
}

void procesarComando(String cmd) {
  if (cmd.length() == 0) return;
  
  cmd.trim();
  cmd.toUpperCase();
  
  if (cmd.indexOf("IOT/SYSTEM/CONSOLE/GET") != -1) {
    publicarBufferSerial();
    return;
  }
  
  consolePrint("Procesando: " + cmd);
  
  // Enviar el comando completo al Master
  enviarComandoI2C(cmd);
  
  // Extraer información para la confirmación
  String tipo = "";
  String dispositivo = "";
  String accion = "";
  String estado = "";
  
  if (cmd.indexOf("IOT/LIGHTS/") != -1) {
    tipo = "LIGHT";
    int start = cmd.indexOf("LIGHT_") + 6;
    int end = cmd.indexOf("/COMMAND");
    if (start > 6 && end != -1) {
      dispositivo = cmd.substring(start, end);
    }
    int pipePos = cmd.indexOf("|");
    if (pipePos != -1) {
      accion = cmd.substring(pipePos + 1);
      estado = accion;
    }
  }
  else if (cmd.indexOf("IOT/DOORS/") != -1) {
    tipo = "DOOR";
    int start = cmd.indexOf("DOOR_") + 5;
    int end = cmd.indexOf("/COMMAND");
    if (start > 5 && end != -1) {
      dispositivo = cmd.substring(start, end);
    }
    int pipePos = cmd.indexOf("|");
    if (pipePos != -1) {
      accion = cmd.substring(pipePos + 1);
      estado = accion;
    }
  }
  else if (cmd.indexOf("IOT/ACTUATORS/VENTILADOR") != -1) {
    tipo = "ACTUATOR";
    dispositivo = "VENTILADOR";
    int pipePos = cmd.indexOf("|");
    if (pipePos != -1) {
      accion = cmd.substring(pipePos + 1);
      estado = accion;
    }
  }
  else if (cmd.indexOf("IOT/SYSTEM/COMMAND") != -1) {
    tipo = "SYSTEM";
    dispositivo = "COMMAND";
    int pipePos = cmd.indexOf("|");
    if (pipePos != -1) {
      accion = cmd.substring(pipePos + 1);
      estado = accion;
    }
  }
  
  if (tipo.length() > 0) {
    publicarConfirmacion(tipo, dispositivo, accion, estado, true);
  }
}

void enviarComandoI2C(String comando) {
  Wire.beginTransmission(1); // Dirección del Master
  Wire.write((const uint8_t*)comando.c_str(), comando.length());
  byte error = Wire.endTransmission();
  
  if (error != 0) {
    consolePrint("ERROR I2C Master (codigo: " + String(error) + ")");
    client.publish("iot/system/gateway/error", "I2C Error: No se pudo enviar comando al Master");
  }
  delay(50);
}

void leerYPublicarEstados() {
  consolePrint("\n--- Leyendo Estados ---");
  
  consolePrint("Estados de Luces: No disponibles (Lectura I2C deshabilitada en Wifi.txt)");
  
  consolePrint("Estados de Sensores: No disponibles (Lectura I2C deshabilitada en Wifi.txt)");
  
  consolePrint("Estados de Puertas: No disponibles (Lectura I2C deshabilitada en Wifi.txt)");
  
  consolePrint("--- Fin Estados ---\n");
}

void leerSerial() {
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\n' || c == '\r') {
      if (serialBuffer.length() > 0) {
        procesarComando(serialBuffer);
        serialBuffer = "";
      }
    } else {
      serialBuffer += c;
    }
  }
}

void receiveEvent(int howMany) {
  String receivedMessage = "";
  while (Wire.available()) {
    char c = Wire.read();
    receivedMessage += c;
  }
  
  if (receivedMessage.length() > 0) {
    if (receivedMessage.startsWith("CONSOLE|")) {
      // Extraer el mensaje de consola
      int firstPipe = receivedMessage.indexOf('|');
      int secondPipe = receivedMessage.indexOf('|', firstPipe + 1);
      if (secondPipe != -1) {
        String source = receivedMessage.substring(firstPipe + 1, secondPipe);
        String message = receivedMessage.substring(secondPipe + 1);
        client.publish("iot/system/console", ("[" + source + "] " + message).c_str());
      }
    } else if (receivedMessage.startsWith("STATE|")) {
      // Extraer el mensaje de estado
      int firstPipe = receivedMessage.indexOf('|');
      String stateMessage = receivedMessage.substring(firstPipe + 1);
      
      int typeEnd = stateMessage.indexOf('|');
      String type = stateMessage.substring(0, typeEnd);
      
      int deviceEnd = stateMessage.indexOf('|', typeEnd + 1);
      String device = stateMessage.substring(typeEnd + 1, deviceEnd);
      
      String state = stateMessage.substring(deviceEnd + 1);
      
      String topic = "";
      if (type == "LIGHT") {
        topic = "iot/lights/LIGHT_" + device + "/status";
      } else if (type == "DOOR") {
        topic = "iot/doors/DOOR_" + device + "/status";
      } else if (type == "SENSOR" && device == "TEMPERATURA") {
        topic = "iot/sensors/TEMPERATURE/status";
      } else if (type == "SENSOR" && device == "DISTANCIA") {
        topic = "iot/sensors/DISTANCE/status";
      } else if (type == "ACTUATOR" && device == "VENTILADOR") {
        topic = "iot/actuators/VENTILADOR/status";
      }
      
      if (topic.length() > 0) {
        client.publish(topic.c_str(), state.c_str());
      }
    }
  }
}


void setup() {
  Serial.begin(115200);
  delay(100);
  
  consolePrint("\n========================================");
  consolePrint("   ESP8266 WiFi Gateway");
  consolePrint("========================================");
  
  Wire.begin(7); // ESP8266 como esclavo I2C con direccion 7
  Wire.onReceive(receiveEvent);
  Wire.setClock(100000);
  consolePrint("I2C inicializado como esclavo");
  
  setup_wifi();
  
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(callback);
  
  consolePrint("\nSistema listo");
  consolePrint("\nDispositivos disponibles:");
  consolePrint("\nLuces:");
  for (int i = 0; i < 9; i++) {
    consolePrint("  - LIGHT_" + luces[i].name);
  }
  consolePrint("\nPuertas:");
  for (int i = 0; i < 8; i++) {
    consolePrint("  - DOOR_" + puertas[i].name);
  }
  consolePrint("\nActuadores:");
  consolePrint("  - VENTILADOR\n");
}

void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    setup_wifi();
  }
  
  if (!client.connected()) {
    reconnect();
  }
  client.loop();
  
  leerSerial();
  
  if (millis() - ultimaLectura >= intervaloLectura) {
    ultimaLectura = millis();
    leerYPublicarEstados();
  }
}
